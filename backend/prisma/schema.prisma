generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================

enum AiProvider {
  openai
  anthropic
  groq
  ollama
  custom
}

enum StrategyType {
  weekly
  monthly
  campaign
}

enum PostStatus {
  draft
  approved
  rejected
  published
}

enum JobType {
  analyze_posts
  generate_strategy
  generate_content
  generate_embeddings
}

enum JobStatus {
  pending
  processing
  completed
  failed
}

// ============================================
// Models
// ============================================

model User {
  id                   String   @id @default(uuid()) @db.Uuid
  email                String   @unique
  passwordHash         String   @map("password_hash")
  name                 String
  bio                  String?
  linkedinUrl          String?  @map("linkedin_url")
  onboardingCompleted  Boolean  @default(false) @map("onboarding_completed")
  preferences          Json     @default("{}")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relations
  apiKeys          ApiKey[]
  linkedinPosts    LinkedInPost[]
  contentStrategies ContentStrategy[]
  generatedPosts   GeneratedPost[]
  jobs             Job[]
  refreshTokens    RefreshToken[]

  @@map("users")
}

model RefreshToken {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  tokenHash    String   @map("token_hash")
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@map("refresh_tokens")
}

model ApiKey {
  id           String     @id @default(uuid()) @db.Uuid
  userId       String     @map("user_id") @db.Uuid
  provider     AiProvider
  encryptedKey String     @map("encrypted_key")
  iv           String     // Initialization vector for AES-GCM
  authTag      String     @map("auth_tag") // Authentication tag for AES-GCM
  modelName    String     @map("model_name")
  isActive     Boolean    @default(true) @map("is_active")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, provider])
  @@map("api_keys")
}

model LinkedInPost {
  id              String   @id @default(uuid()) @db.Uuid
  userId          String   @map("user_id") @db.Uuid
  postText        String   @map("post_text") @db.Text
  postTextHash    String   @map("post_text_hash") // For deduplication
  postUrl         String?  @map("post_url")
  likesCount      Int      @default(0) @map("likes_count")
  commentsCount   Int      @default(0) @map("comments_count")
  sharesCount     Int      @default(0) @map("shares_count")
  postedAt        DateTime @map("posted_at")
  topics          String[] @default([])
  sentimentScore  Float?   @map("sentiment_score")
  // Embedding stored via raw SQL (pgvector)
  createdAt       DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postTextHash])
  @@index([userId])
  @@index([postedAt(sort: Desc)])
  @@index([topics], type: Gin)
  @@map("linkedin_posts")
}

model ContentStrategy {
  id                String       @id @default(uuid()) @db.Uuid
  userId            String       @map("user_id") @db.Uuid
  strategyType      StrategyType @map("strategy_type")
  themes            Json         @default("[]")
  postingFrequency  Int          @map("posting_frequency")
  targetAudience    Json         @default("{}") @map("target_audience")
  goals             Json         @default("{}") @map("goals")
  generatedAt       DateTime     @default(now()) @map("generated_at")
  expiresAt         DateTime     @map("expires_at")

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  generatedPosts GeneratedPost[]

  @@index([userId])
  @@map("content_strategies")
}

model GeneratedPost {
  id                  String     @id @default(uuid()) @db.Uuid
  userId              String     @map("user_id") @db.Uuid
  strategyId          String?    @map("strategy_id") @db.Uuid
  postText            String     @map("post_text") @db.Text
  topic               String
  hook                String
  cta                 String
  generationMetadata  Json       @default("{}") @map("generation_metadata")
  status              PostStatus @default(draft)
  userFeedback        String?    @map("user_feedback") @db.Text
  feedbackRating      Int?       @map("feedback_rating")
  // Embedding stored via raw SQL (pgvector)
  createdAt           DateTime   @default(now()) @map("created_at")
  updatedAt           DateTime   @updatedAt @map("updated_at")

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategy ContentStrategy? @relation(fields: [strategyId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@map("generated_posts")
}

model Job {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @map("user_id") @db.Uuid
  jobType      JobType   @map("job_type")
  status       JobStatus @default(pending)
  inputData    Json?     @map("input_data")
  resultData   Json?     @map("result_data")
  errorMessage String?   @map("error_message") @db.Text
  progress     Int       @default(0)
  attempts     Int       @default(0)
  createdAt    DateTime  @default(now()) @map("created_at")
  completedAt  DateTime? @map("completed_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@map("jobs")
}
